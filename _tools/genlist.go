// +build ignore

package main

import (
	"bytes"
	"container/list"
	"flag"
	"fmt"
	"go/format"
	"io"
	"os"
	"reflect"
	"strings"

	"golang.org/x/tools/imports"
)

type replacer map[string]string

func (r replacer) StringOf(typ reflect.Type) string {
	var prefix string
	for typ.Kind() == reflect.Ptr {
		prefix += "*"
		typ = typ.Elem()
	}
	s := typ.String()
	if rep, ok := r[s]; ok {
		s = rep
	}
	return prefix + s
}

func toVarName(typ reflect.Type) string {
	// interface{} is used as value
	if typ.String() == "interface {}" {
		return "v"
	}
	typ = indirectType(typ)
	s := strings.TrimFunc(typ.Name(), func(c rune) bool {
		return !(c >= 'A' && c <= 'Z')
	})
	return strings.ToLower(s)
}

func indirectType(typ reflect.Type) reflect.Type {
	for typ.Kind() == reflect.Ptr {
		typ = typ.Elem()
	}
	return typ
}

func genHeader(w io.Writer, imports []string) {
	fmt.Fprintf(w, "// Code generated by %q; DO NOT EDIT THIS FILE.\n", strings.Join(append([]string{"go", "run", "genlist.go"}, os.Args[1:]...), " "))
	fmt.Fprint(w, "\n")
	fmt.Fprint(w, "package goen\n")
	fmt.Fprint(w, "\n")
	fmt.Fprint(w, "import (\n")
	for _, pkg := range imports {
		fmt.Fprintf(w, "\t%q\n", pkg)
	}
	fmt.Fprint(w, ")\n")
	fmt.Fprint(w, "\n")
}

func genList(w io.Writer, rep replacer) {
	typ := reflect.TypeOf(list.New())

	fmt.Fprintf(w, "// %s is typed version of %s\n", rep.StringOf(indirectType(typ)), indirectType(typ))
	fmt.Fprintf(w, "type %s %s\n", rep.StringOf(indirectType(typ)), indirectType(typ))
	fmt.Fprint(w, "\n")
	fmt.Fprintf(w, "func wrap%[1]sOrNil(e *list.Element) *%[1]s {\n", rep.StringOf(indirectType(reflect.TypeOf(list.Element{}))))
	fmt.Fprint(w, "\tif e == nil {\n")
	fmt.Fprint(w, "\t\treturn nil\n")
	fmt.Fprint(w, "\t}\n")
	fmt.Fprintf(w, "\treturn &%s{e}\n", rep.StringOf(indirectType(reflect.TypeOf(list.Element{}))))
	fmt.Fprint(w, "}\n")
	fmt.Fprint(w, "\n")

	typs := []reflect.Type{typ, typ.Elem()}
	for _, typ := range typs {
		receiver := toVarName(typ)
		altTypStr := rep.StringOf(typ)

		for i := 0; i < typ.NumMethod(); i++ {
			method := typ.Method(i)
			// In(0) is just a receiver
			in := make([]string, method.Type.NumIn()-1)
			inVars := make([]string, method.Type.NumIn()-1)
			inCastVars := make([]string, method.Type.NumIn()-1)
			for j := 1; j < method.Type.NumIn(); j++ {
				inTyp := method.Type.In(j)
				altInTypStr := rep.StringOf(inTyp)
				// arg var name is visible on godoc, be careful
				var varName string
				switch {
				case strings.HasSuffix(method.Name, "List"):
					varName = "other"
				case j == 2 && strings.HasSuffix(method.Name, "After"):
					varName = "mark"
				case j == 2 && strings.HasSuffix(method.Name, "Before"):
					varName = "mark"
				}
				if varName == "" {
					varName = toVarName(inTyp)
				}

				in[j-1] = fmt.Sprintf("%s %s", varName, altInTypStr)
				inVars[j-1] = varName
				if inTyp.String() == "interface {}" {
					inCastVars[j-1] = varName
				} else if indirectType(inTyp).String() == "list.Element" {
					inCastVars[j-1] = fmt.Sprintf("%s.el", varName)
				} else {
					inCastVars[j-1] = fmt.Sprintf("(%s)(%s)", inTyp, varName)
				}
			}
			out := make([]string, method.Type.NumOut())
			outVars := make([]string, method.Type.NumOut())
			outCastVars := make([]string, method.Type.NumOut())
			for j := 0; j < method.Type.NumOut(); j++ {
				outTyp := method.Type.Out(j)
				altOutTypStr := rep.StringOf(outTyp)

				out[j] = altOutTypStr
				outVars[j] = fmt.Sprintf("ret%d", j)
				if outTyp.String() == "interface {}" {
					outCastVars[j] = fmt.Sprintf("ret%d.(%s)", j, altOutTypStr)
				} else if iot := indirectType(outTyp); iot.String() == "list.Element" {
					outCastVars[j] = fmt.Sprintf("wrap%sOrNil(ret%d)", rep.StringOf(iot), j)
				} else {
					outCastVars[j] = fmt.Sprintf("(%s)(ret%d)", altOutTypStr, j)
				}
			}

			fmt.Fprint(w, "\n")
			fmt.Fprintf(w, "// %s is typed version of (%s).%s\n", method.Name, typ, method.Name)
			fmt.Fprintf(w, "func (%s %s) %s(%s) (%s) {\n", receiver, altTypStr, method.Name, strings.Join(in, ", "), strings.Join(out, ", "))
			if len(out) > 0 {
				fmt.Fprintf(w, "\t%s := (%s)(%s).%s(%s)\n", strings.Join(outVars, ", "), typ, receiver, method.Name, strings.Join(inCastVars, ", "))
				fmt.Fprintf(w, "\treturn %s\n", strings.Join(outCastVars, ", "))
			} else {
				fmt.Fprintf(w, "\t(%s)(%s).%s(%s)\n", typ, receiver, method.Name, strings.Join(inCastVars, ", "))
			}
			fmt.Fprint(w, "}\n")
		}
	}
}

func genElement(w io.Writer, rep replacer) {
	altTypStr := rep.StringOf(reflect.TypeOf(list.Element{}))
	altElStr := rep.StringOf(reflect.TypeOf((*interface{})(nil)).Elem())

	fmt.Fprintf(w, "// %s is typed version of list.Element\n", altTypStr)
	fmt.Fprintf(w, "type %s struct {\n", altTypStr)
	fmt.Fprint(w, "\tel *list.Element\n")
	fmt.Fprint(w, "}\n")
	fmt.Fprint(w, "\n")
	fmt.Fprint(w, "// Next returns the next list element or nil.\n")
	fmt.Fprintf(w, "func (e *%s) Next() *%s {\n", altTypStr, altTypStr)
	fmt.Fprintf(w, "\treturn wrap%sOrNil(e.el.Next())\n", altTypStr)
	fmt.Fprint(w, "}\n")
	fmt.Fprint(w, "\n")
	fmt.Fprint(w, "// Prev returns the previous list element or nil.\n")
	fmt.Fprintf(w, "func (e *%s) Prev() *%s {\n", altTypStr, altTypStr)
	fmt.Fprintf(w, "\treturn wrap%sOrNil(e.el.Prev())\n", altTypStr)
	fmt.Fprint(w, "}\n")
	fmt.Fprint(w, "\n")
	fmt.Fprint(w, "// GetValue gets the value stored with this element.\n")
	fmt.Fprintf(w, "func (e *%s) GetValue() %s {\n", altTypStr, altElStr)
	fmt.Fprintf(w, "\treturn e.el.Value.(%s)\n", altElStr)
	fmt.Fprint(w, "}\n")
	fmt.Fprint(w, "\n")
	fmt.Fprint(w, "// SetValue sets value with this element.\n")
	fmt.Fprintf(w, "func (e *%s) SetValue(v %s) {\n", altTypStr, altElStr)
	fmt.Fprint(w, "\te.el.Value = v\n")
	fmt.Fprint(w, "}\n")
}

func main() {
	debug := flag.Bool("debug", false, "")
	outfile := flag.String("o", "-", "")
	flag.Parse()

	buf := new(bytes.Buffer)
	genHeader(buf, []string{
		"container/list",
		"github.com/Masterminds/squirrel",
	})
	replacers := []replacer{
		replacer{
			"list.List":    "PatchList",
			"list.Element": "PatchElement",
			"interface {}": "*Patch",
		},
		replacer{
			"list.List":    "SqlizerList",
			"list.Element": "SqlizerElement",
			"interface {}": "squirrel.Sqlizer",
		},
	}
	for _, rep := range replacers {
		genList(buf, rep)
		genElement(buf, rep)
	}
	src := buf.Bytes()
	if !*debug {
		var err error
		src, err = format.Source(src)
		if err != nil {
			panic(err)
		}
		src, err = imports.Process("", src, &imports.Options{
			AllErrors:  true,
			FormatOnly: true,
			Comments:   true,
		})
		if err != nil {
			panic(err)
		}
	}
	var out io.Writer
	if *outfile == "-" {
		out = os.Stdout
	} else {
		file, err := os.Create(*outfile)
		if err != nil {
			panic(err)
		}
		defer file.Close()
		out = file
	}
	if _, err := io.Copy(out, bytes.NewReader(src)); err != nil {
		panic(err)
	}
}
